group LLVM;

typeInitMap ::= [
    default:   "null"
]

program(type_defs, globals, global_code, code, vector_sizes_init) ::= <<
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

<runtime_library()>
<externs()>

<type_defs; separator="\n">

<string_constants()>

<globals>

define void @initGlobals() {
<vector_sizes_init; separator="\n">
<global_code>
  ret void;
}

<code>
>>

void_type() ::= <<
void
>>

vglobalSymbol(id) ::= <<
@__<id>_symbol
>>

vlocal(id) ::= <<
%__<id>_
>>
vlocal_result(id) ::= <<
%__<id>_result
>>
vlocal_symbol(id) ::= <<
%__<id>_symbol
>>
vlocal_argument(id) ::= <<
%__<id>_argument
>>
fglobal(id) ::= <<
@___func<id>
>>

vloop_entry(id) ::= <<
loop.entry_<id>_
>>
vloop_body(id) ::= <<
loop.body_<id>_
>>
vloop_done(id) ::= <<
loop.done_<id>_
>>

runtime_library() ::= <<
declare i32 @powi(i32 %a, i32 %n)
declare i1 @readBoolean()
declare i8 @readCharacter()
declare i32 @readInteger()
declare float @readReal()
declare i32 @getStreamState()

declare void @gc_add_method()
declare void @gc_add_block()
declare void @gc_add_loop()

declare void @gc_free_method()
declare void @gc_free_loop()

declare void @gc_print()

declare i8* @int_allocInterval(i32, i32)
declare void @int_assignInterval(i8*, i8*)
declare void @int_IntervalAdd(i8*, i8*, i8*)
declare void @int_IntervalSubtract(i8*, i8*, i8*)
declare void @int_IntervalMultiply(i8*, i8*, i8*)
declare void @int_IntervalDivide(i8*, i8*, i8*)
declare void @int_IntervalUniaryMinus(i8*, i8*)
declare i1  @int_IntervalEq(i8*, i8*)
declare i1  @int_IntervalNe(i8*, i8*)
declare i1  @int_IntervalBy(i8*, i8*, i32)
declare i32 @int_IntervalRange(i8*)
declare void @int_printInterval(i8*)
declare void @int_releaseInterval(i8*)

declare void @bool_allocVector(i8*, i32)
declare void @bool_assignVector(i8*, i8*)
declare void @bool_assignVectorScalar(i8*, i1)
declare void @bool_copyVector(i8*, i8*)
declare i1  @bool_getElement(i1*, i8*, i32)
declare i1  @bool_setElement(i8*, i32, i1)
declare void @bool_VectorNot(i8*, i8*)
declare void  @bool_VectorOrVector(i8*, i8*, i8*)
declare void  @bool_VectorXOrVector(i8*, i8*, i8*)
declare void  @bool_VectorAndVector(i8*, i8*, i8*)
declare void @bool_VectorOrScalar(i8*, i8*, i1)
declare void @bool_VectorXOrScalar(i8*, i8*, i1)
declare void @bool_VectorAndScalar(i8*, i8*, i1)
declare i1  @bool_VectorEq(i8*, i8*)
declare i1  @bool_VectorNe(i8*, i8*)
declare i1 @bool_VectorBy(i8*, i8*, i32)
declare void  @bool_VectorConcatVector(i8*, i8*, i8*)
declare void  @bool_printVector(i8*)

declare void @char_allocVector(i8*, i32)
declare void @char_assignVector(i8*, i8*)
declare void @char_assignVectorScalar(i8*, i8)
declare void @char_copyVector(i8*, i8*)
declare i1  @char_getElement(i8*, i8*, i32)
declare i1  @char_setElement(i8*, i32, i8)
declare i1  @char_VectorEq(i8*, i8*)
declare i1  @char_VectorNe(i8*, i8*)
declare i1 @char_VectorBy(i8*, i8*, i32)
declare void  @char_VectorConcatVector(i8*, i8*, i8*)
declare void  @char_printVector(i8*)

declare void @int_allocVector(i8*, i32)
declare void @int_assignVector(i8*, i8*)
declare void @int_assignVectorScalar(i8*, i32)
declare void @int_copyVector(i8*, i8*)
declare i1  @int_getElement(i32*, i8*, i32)
declare i1  @int_setElement(i8*, i32, i32)
declare i1  @int_indexVector(i8*, i8*, i8*) 
declare void  @int_VectorAddVector(i8*, i8*, i8*)
declare void  @int_VectorAddScalar(i8*, i8*, i32)
declare void  @int_VectorSubtractVector(i8*, i8*, i8*)
declare void  @int_VectorSubtractScalar(i8*, i8*, i32)
declare void  @int_ScalarSubtractVector(i8*, i32, i8*)
declare void  @int_VectorMultiplyVector(i8*, i8*, i8*)
declare void  @int_VectorMultiplyScalar(i8*, i8*, i32)
declare void  @int_VectorDivideVector(i8*, i8*, i8*)
declare void  @int_VectorDivideScalar(i8*, i8*, i32)
declare void  @int_ScalarDivideVector(i8*, i32, i8*)
declare void  @int_VectorModulusVector(i8*, i8*, i8*)
declare void  @int_VectorModulusScalar(i8*, i8*, i32)
declare void  @int_ScalarModulusVector(i8*, i32, i8*)
declare void  @int_VectorPowerVector(i8*, i8*, i8*)
declare void  @int_VectorPowerScalar(i8*, i8*, i32)
declare void  @int_ScalarPowerVector(i8*, i32, i8*)
declare void  @int_VectorUniaryMinus(i8*, i8*)
declare void  @int_VectorDot(i32*, i8*, i8*)
declare void  @int_VectorLTVector(i8*, i8*, i8*)
declare void  @int_VectorLEVector(i8*, i8*, i8*)
declare void  @int_VectorGTVector(i8*, i8*, i8*)
declare void  @int_VectorGEVector(i8*, i8*, i8*)
declare i1  @int_VectorEq(i8*, i8*)
declare i1  @int_VectorNe(i8*, i8*)
declare i1 @int_VectorBy(i8*, i8*, i32)
declare void  @int_VectorConcatVector(i8*, i8*, i8*)
declare void  @int_VectorToReal(i8*, i8*)
declare void  @int_printVector(i8*)

declare void @real_allocVector(i8*, i32)
declare void @real_assignVector(i8*, i8*)
declare void @real_assignVectorScalar(i8*, float)
declare void @real_copyVector(i8*, i8*)
declare i1  @real_getElement(float*, i8*, i32)
declare i1  @real_setElement(i8*, i32, float)
declare void  @real_VectorAddVector(i8*, i8*, i8*)
declare void  @real_VectorAddScalar(i8*, i8*, float)
declare void  @real_VectorSubtractVector(i8*, i8*, i8*)
declare void  @real_VectorSubtractScalar(i8*, i8*, float)
declare void  @real_ScalarSubtractVector(i8*, float, i8*)
declare void  @real_VectorMultiplyVector(i8*, i8*, i8*)
declare void  @real_VectorMultiplyScalar(i8*, i8*, float)
declare void  @real_VectorDivideVector(i8*, i8*, i8*)
declare void  @real_VectorDivideScalar(i8*, i8*, float)
declare void  @real_ScalarDivideVector(i8*, float, i8*)
declare void  @real_VectorModulusVector(i8*, i8*, i8*)
declare void  @real_VectorModulusScalar(i8*, i8*, float)
declare void  @real_ScalarModulusVector(i8*, float, i8*)
declare void  @real_VectorPowerVector(i8*, i8*, i8*)
declare void  @real_VectorUniaryMinus(i8*, i8*)
declare void  @real_VectorDot(float*, i8*, i8*)
declare i1  @real_VectorEq(i8*, i8*)
declare i1  @real_VectorNe(i8*, i8*)
declare i1 @real_VectorBy(i8*, i8*, i32)
declare void  @real_VectorConcatVector(i8*, i8*, i8*)
declare void  @real_printVector(i8*)

declare i8*  @allocVector()
declare i8*  @getData(i8*)
declare i32  @getVectorSize(i8*)
declare i1 @checkVectorsAreOfSameLength(i8*, i8*)
declare i1 @checkVectorsRHSLength(i8*, i8*)
declare void @releaseVector(i8*)

>>

externs() ::= <<
declare i32 @printf(i8*, ...)
declare float @llvm.pow.f32(float, float) nounwind readonly
declare float @llvm.floor.f32(float)
declare i8* @llvm.stacksave()
declare void @llvm.stackrestore(i8* %ptr)
declare i32 @__isoc99_scanf(i8*, ...)
>>

string_constants() ::= <<
@.str.lbrack = private unnamed_addr constant [2 x i8] c"[\00"
@.str.rbrack = private unnamed_addr constant [3 x i8] c" ]\00"
@.str.newline = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.fmt.boolT = private unnamed_addr constant [2 x i8] c"T\00", align 1
@.str.fmt.boolT.newline = private unnamed_addr constant [3 x i8] c"T\0A\00", align 1
@.str.fmt.boolT.lspace = private unnamed_addr constant [3 x i8] c" T\00", align 1
@.str.fmt.boolF = private unnamed_addr constant [2 x i8] c"F\00", align 1
@.str.fmt.boolF.newline = private unnamed_addr constant [3 x i8] c"F\0A\00", align 1
@.str.fmt.boolF.lspace = private unnamed_addr constant [3 x i8] c" F\00", align 1
@.str.fmt.char = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.fmt.char.newline = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
@.str.fmt.char.lspace = private unnamed_addr constant [4 x i8] c" %c\00", align 1
@.str.fmt.int = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.fmt.int.newline = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.fmt.int.lspace = private unnamed_addr constant [4 x i8] c" %d\00", align 1
@.str.fmt.float = private unnamed_addr constant [3 x i8] c"%g\00", align 1
@.str.fmt.float.newline = private unnamed_addr constant [4 x i8] c"%g\0A\00", align 1
@.str.fmt.float.lspace = private unnamed_addr constant [4 x i8] c" %g\00", align 1

@.str.input.char = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
@.str.input.int = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.input.real = private unnamed_addr constant [4 x i8] c"%g\0A\00", align 1
>>

function_main(id, code) ::= <<
define i32 @main() nounwind uwtable {
call void @gc_add_method()
call void @initGlobals()
<code; separator="\n">
}
>>

function(id, sym_id, return_type, args, code) ::= <<
define <return_type> <fglobal(sym_id)>(<args; separator=", ">) {
<code; separator="\n">
}
>>

function_returning_tuple(id, sym_id, type_id, args, code) ::= <<
define void <fglobal(sym_id)>(<args; separator=", "><if(args)>, <endif><tuple_type(type_id)>* %tuple_return) {
<code; separator="\n">
}
>>

declare_argument(id, arg_id, arg_type) ::= <<
<arg_type>* <vlocal_symbol(arg_id)>
>>

pass_variable_by_reference(id, var_id, arg_type) ::= <<
<arg_type>* <vlocal_symbol(var_id)>
>>

pass_expr_by_reference(id, arg_expr_id, arg_type) ::= <<
<arg_type>* <vlocal_result(arg_expr_id)>_stackptr
>>

pass_tuple_expr_by_reference(id, tuple_expr_id, type_id) ::= <<
<tuple_type(type_id)>* <vlocal_result(tuple_expr_id)>
>>

expr_result_to_stack(id, expr_id, expr_type) ::= <<
  <vlocal_result(expr_id)>_stackptr = alloca <expr_type>;
  store <expr_type> <vlocal_result(expr_id)>, <expr_type>* <vlocal_result(expr_id)>_stackptr
>>

save_stack(id, call_id) ::= <<
  <vlocal(call_id)>stack = call i8*()* @llvm.stacksave()
>>

restore_stack(id, call_id) ::= <<
  call void(i8*)* @llvm.stackrestore(i8* <vlocal(call_id)>stack)
>>

arg_init(id, arg_id, arg_type) ::= <<
  <vlocal_symbol(arg_id)> = alloca <arg_type>
  store <arg_type> <vlocal_argument(arg_id)>, <arg_type>* <vlocal_symbol(arg_id)>
>>

return_main(id, expr, expr_id, type) ::= <<
<expr>
  call void @gc_free_method()
  ;call void @gc_print()
  ret <type> <vlocal_result(expr_id)>
>>

return(id, expr, expr_id, type) ::= <<
<expr>
  ret <type> <vlocal_result(expr_id)>
>>

return_tuple(id, assign_code, type_id) ::= <<
  <vlocal_result(id)> = bitcast <tuple_type(type_id)>* %tuple_return to <tuple_type(type_id)>*
<assign_code>
  ret void
>>

call_void(id, function_id, args, code, postcode) ::= <<
<code; separator="\n">
  call void @gc_add_method()
  call void <fglobal(function_id)>(<args; separator=", ">)
  call void @gc_free_method()
<postcode; separator="\n">
>>

call(id, function_id, return_type, args, code, postcode) ::= <<
<code; separator="\n">
  call void @gc_add_method()
  <vlocal_result(id)> = call <return_type> <fglobal(function_id)>(<args; separator=", ">)
  call void @gc_free_method()
<postcode; separator="\n">
>>

call_returning_tuple(id, function_id, type_id, args, code, postcode) ::= <<
<code; separator="\n">
  <vlocal_result(id)> = alloca <tuple_type(type_id)>
  call void @gc_add_method()
  call void <fglobal(function_id)>(<args; separator=", "><if(args)>, <endif><tuple_type(type_id)>* <vlocal_result(id)>)
  call void @gc_free_method()
<postcode; separator="\n">
>>

call_returning_vector(id, function_id, type_name, vector_size, vector_size_id, type_id, args, code, postcode) ::= <<
<code; separator="\n">
  <vector_size>
  <vlocal(id)>_vec  = alloca i8*
  <vlocal_result(id)> = call i8* @allocVector()
  call void @<type_name>_allocVector(i8* <vlocal_result(id)>, i32 <vlocal_result(vector_size_id)>)
  store i8* <vlocal_result(id)>, i8** <vlocal(id)>_vec
  
  call void @gc_add_method()
  <vlocal(id)>_tmp = call i8* <fglobal(function_id)>(<args; separator=", ">)
  call void @<type_name>_assignVector(i8* <vlocal_result(id)>, i8*  <vlocal(id)>_tmp)
  call void @gc_free_method()
<postcode; separator="\n">
>>

call_stream_state(id) ::= <<
  <vlocal_result(id)> = call i32 @getStreamState()
>>

call_length(id, vector_expr, vector_expr_id) ::= <<
  <vector_expr>
  <vlocal_result(id)> = call i32 @getVectorSize(i8* <vlocal_result(vector_expr_id)>)
>>

if(id, expr, expr_id, block) ::= <<
  <expr>
  br i1 <vlocal_result(expr_id)>, label %if.body<id>, label %if.done<id>

if.body<id>:
  <block>
  br label %if.done<id>
  
if.done<id>:

>>

if_else(id, expr, expr_id, block, block2) ::= <<
  <expr>
  br i1 <vlocal_result(expr_id)>, label %if.body<id>, label %if.else<id>

if.body<id>:
  <block>
  br label %if.done<id>

if.else<id>:
  <block2>
  br label %if.done<id>
  
if.done<id>:

>>

while(id, expr, expr_id, block) ::= <<
br label %<vloop_entry(id)>

<vloop_entry(id)>:
  <expr>
  br i1 <vlocal_result(expr_id)>, label %<vloop_body(id)>, label %<vloop_done(id)>

<vloop_body(id)>:
  call void @gc_add_loop()
  <block>
  call void @gc_free_loop()
  br label %<vloop_entry(id)>

<vloop_done(id)>:

>>

dowhile(id, expr, expr_id, block) ::= <<
br label %<vloop_entry(id)>

<vloop_entry(id)>:
  call void @gc_add_loop()
  <block>
  call void @gc_free_loop()
  
  <expr>
  br i1 <vlocal_result(expr_id)>, label %<vloop_entry(id)>, label %<vloop_done(id)>
  
<vloop_done(id)>:

>>

loop(id, block) ::= <<
br label %<vloop_entry(id)>

<vloop_entry(id)>:
  call void @gc_add_loop()
  <block>
  call void @gc_free_loop()
  
  br label %<vloop_entry(id)>
  
<vloop_done(id)>:

>>

iterator(id, sym_id, type_name, llvm_type, expr, expr_id, block) ::= <<
<vlocal_symbol(sym_id)> = alloca <llvm_type>
<vlocal(id)>_i  = alloca i32
store i32 1, i32* <vlocal(id)>_i
<expr>
<vlocal(id)>_size = call i32 @getVectorSize(i8* <vlocal_result(expr_id)>)

br label %<vloop_entry(id)>

<vloop_entry(id)>:
  <vlocal(id)>_i_tmp = load i32* <vlocal(id)>_i
  <vlocal(id)>_end = icmp sle i32 <vlocal(id)>_i_tmp, <vlocal(id)>_size
  br i1 <vlocal(id)>_end, label %<vloop_body(id)>, label %<vloop_done(id)>

<vloop_body(id)>:
  <vlocal(id)>_index = load i32* <vlocal(id)>_i
  <vlocal(id)>_success = call i1 @<type_name>_getElement(<llvm_type>* <vlocal_symbol(sym_id)>, i8* <vlocal_result(expr_id)>, i32 <vlocal(id)>_index)
  call void @gc_add_loop()
  <block>
  call void @gc_free_loop()
  <vlocal(id)>_index_increment = add i32 <vlocal(id)>_index, 1
  store i32 <vlocal(id)>_index_increment, i32* <vlocal(id)>_i
  br label %<vloop_entry(id)>

<vloop_done(id)>:

>>

break(id, loop_id) ::= <<
  call void @gc_free_loop()
  br label %<vloop_done(loop_id)>
>>

continue(id, loop_id) ::= <<
  call void @gc_free_loop()
  br label %<vloop_entry(loop_id)>
>>

