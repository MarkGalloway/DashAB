group LLVM;

typeInitMap ::= [
    default:   "null"
]

program(type_defs, globals, global_code, code) ::= <<
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }

@stream_state = global i32 0, align 4
@stdin = external global %struct._IO_FILE*

<externs()>

<type_defs; separator="\n">

<string_constants()>

<globals>

define void @initGlobals() {
<global_code>
  ret void;
}

<code>

<utils()>
>>

void_type() ::= <<
void
>>

vglobalSymbol(id) ::= <<
@__<id>_symbol
>>

vlocal(id) ::= <<
%__<id>_
>>
vlocal_result(id) ::= <<
%__<id>_result
>>
vlocal_symbol(id) ::= <<
%__<id>_symbol
>>
vlocal_argument(id) ::= <<
%__<id>_argument
>>
fglobal(id) ::= <<
@___func<id>
>>

vloop_entry(id) ::= <<
loop.entry_<id>_
>>
vloop_body(id) ::= <<
loop.body_<id>_
>>
vloop_done(id) ::= <<
loop.done_<id>_
>>

externs() ::= <<
declare i32 @puts(i8* nocapture) nounwind
declare i32 @printf(i8*, ...)
declare i8* @malloc(i32)
declare i8* @calloc(i32, i32)
declare void @free(i8*)
declare void @exit(i32)
declare float @llvm.pow.f32(float, float) nounwind readonly
declare i8* @llvm.stacksave()
declare void @llvm.stackrestore(i8* %ptr)
declare i32 @feof(%struct._IO_FILE* nocapture) #1
declare i32 @__isoc99_scanf(i8* nocapture readonly, ...) #1
>>

string_constants() ::= <<
@.str.lbrack = private unnamed_addr constant [2 x i8] c"[\00"
@.str.rbrack = private unnamed_addr constant [3 x i8] c" ]\00"
@.str.newline = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.fmt.boolT = private unnamed_addr constant [2 x i8] c"T\00", align 1
@.str.fmt.boolT.newline = private unnamed_addr constant [3 x i8] c"T\0A\00", align 1
@.str.fmt.boolT.lspace = private unnamed_addr constant [3 x i8] c" T\00", align 1
@.str.fmt.boolF = private unnamed_addr constant [2 x i8] c"F\00", align 1
@.str.fmt.boolF.newline = private unnamed_addr constant [3 x i8] c"F\0A\00", align 1
@.str.fmt.boolF.lspace = private unnamed_addr constant [3 x i8] c" F\00", align 1
@.str.fmt.char = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.fmt.char.newline = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
@.str.fmt.char.lspace = private unnamed_addr constant [4 x i8] c" %c\00", align 1
@.str.fmt.int = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.fmt.int.newline = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.fmt.int.lspace = private unnamed_addr constant [4 x i8] c" %d\00", align 1
@.str.fmt.float = private unnamed_addr constant [3 x i8] c"%g\00", align 1
@.str.fmt.float.newline = private unnamed_addr constant [4 x i8] c"%g\0A\00", align 1
@.str.fmt.float.lspace = private unnamed_addr constant [4 x i8] c" %g\00", align 1

@.str.input.char = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
@.str.input.int = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.input.real = private unnamed_addr constant [4 x i8] c"%g\0A\00", align 1
>>

utils() ::= <<
; Function Attrs: nounwind readnone uwtable
define i32 @powi(i32 %a, i32 %n) #0 {
entry:
  %cmp10 = icmp sgt i32 %n, 0
  br i1 %cmp10, label %while.body.preheader, label %while.end

while.body.preheader:                             ; preds = %entry
  br label %while.body

while.body:                                       ; preds = %if.end, %while.body.preheader
  %value.013 = phi i32 [ %rem2, %if.end ], [ %a, %while.body.preheader ]
  %power.012 = phi i32 [ %shr, %if.end ], [ %n, %while.body.preheader ]
  %result.011 = phi i32 [ %result.1, %if.end ], [ 1, %while.body.preheader ]
  %and = and i32 %power.012, 1
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %mul = mul nsw i32 %value.013, %result.011
  %rem = srem i32 %mul, 1000000007
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %result.1 = phi i32 [ %rem, %if.then ], [ %result.011, %while.body ]
  %mul1 = mul nsw i32 %value.013, %value.013
  %rem2 = urem i32 %mul1, 1000000007
  %shr = ashr i32 %power.012, 1
  %cmp = icmp sgt i32 %shr, 0
  br i1 %cmp, label %while.body, label %while.end.loopexit

while.end.loopexit:                               ; preds = %if.end
  %result.1.lcssa = phi i32 [ %result.1, %if.end ]
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %entry
  %result.0.lcssa = phi i32 [ 1, %entry ], [ %result.1.lcssa, %while.end.loopexit ]
  ret i32 %result.0.lcssa
}


; Function Attrs: nounwind uwtable
define i1 @readBool() #0 {
entry:
  %retval = alloca i1, align 4
  %input = alloca i8, align 1
  %call = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([4 x i8]* @.str.input.char, i32 0, i32 0), i8* %input)
  %0 = load i8* %input, align 1
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 84
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i1 1, i1* %retval
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i8* %input, align 1
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 70
  br i1 %cmp3, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  store i1 0, i1* %retval
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  store i32 1, i32* @stream_state, align 4
  store i1 0, i1* %retval
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %2 = load i1* %retval
  ret i1 %2
}

; Function Attrs: nounwind uwtable
define signext i8 @readChar() #0 {
entry:
  %input = alloca i8, align 1
  %call = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([4 x i8]* @.str.input.char, i32 0, i32 0), i8* %input)
  %0 = load i8* %input, align 1
  ret i8 %0
}

; Function Attrs: nounwind uwtable
define i32 @readInt() #0 {
entry:
  %input = alloca i32, align 4
  %call = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([4 x i8]* @.str.input.int, i32 0, i32 0), i32* %input)
  %0 = load i32* %input, align 4
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define float @readFloat() #0 {
entry:
  %input = alloca float, align 4
  %call = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([4 x i8]* @.str.input.real, i32 0, i32 0), float* %input)
  %0 = load float* %input, align 4
  ret float %0
}

>>

function_main(id, code) ::= <<
define i32 @main() nounwind uwtable {
call void @initGlobals()
<code; separator="\n">
}
>>

function(id, sym_id, return_type, args, code) ::= <<
define <return_type> <fglobal(sym_id)>(<args; separator=", ">) {
<code; separator="\n">
}
>>

declare_argument(id, arg_id, arg_type) ::= <<
<arg_type>* <vlocal_symbol(arg_id)>
>>

pass_variable_by_reference(id, var_id, arg_type) ::= <<
<arg_type>* <vlocal_symbol(var_id)>
>>

pass_expr_by_reference(id, arg_expr_id, arg_type) ::= <<
<arg_type>* <vlocal_result(arg_expr_id)>_stackptr
>>

expr_result_to_stack(id, expr_id, expr_type) ::= <<
  <vlocal_result(expr_id)>_stackptr = alloca <expr_type>;
  store <expr_type> <vlocal_result(expr_id)>, <expr_type>* <vlocal_result(expr_id)>_stackptr
>>

save_stack(id, call_id) ::= <<
  <vlocal(call_id)>stack = call i8*()* @llvm.stacksave()
>>

restore_stack(id, call_id) ::= <<
  call void(i8*)* @llvm.stackrestore(i8* <vlocal(call_id)>stack)
>>

arg_init(id, arg_id, arg_type) ::= <<
  <vlocal_symbol(arg_id)> = alloca <arg_type>
  store <arg_type> <vlocal_argument(arg_id)>, <arg_type>* <vlocal_symbol(arg_id)>
>>


return(id, expr, expr_id, type) ::= <<
<expr>
  ret <type> <vlocal_result(expr_id)>
>>

call_void(id, function_id, args, code, postcode) ::= <<
<code; separator="\n">
  call void <fglobal(function_id)>(<args; separator=", ">)
<postcode; separator="\n">
>>

call(id, function_id, return_type, args, code, postcode) ::= <<
<code; separator="\n">
  <vlocal_result(id)> = call <return_type> <fglobal(function_id)>(<args; separator=", ">)
<postcode; separator="\n">
>>

if(id, expr, expr_id, block) ::= <<
  <expr>
  br i1 <vlocal_result(expr_id)>, label %if.body<id>, label %if.done<id>

if.body<id>:
  <block>
  br label %if.done<id>
  
if.done<id>:

>>

if_else(id, expr, expr_id, block, block2) ::= <<
  <expr>
  br i1 <vlocal_result(expr_id)>, label %if.body<id>, label %if.else<id>

if.body<id>:
  <block>
  br label %if.done<id>

if.else<id>:
  <block2>
  br label %if.done<id>
  
if.done<id>:

>>

while(id, expr, expr_id, block) ::= <<
br label %<vloop_entry(id)>

<vloop_entry(id)>:
  <expr>
  br i1 <vlocal_result(expr_id)>, label %<vloop_body(id)>, label %<vloop_done(id)>

<vloop_body(id)>:
  <block>
  br label %<vloop_entry(id)>

<vloop_done(id)>:

>>

dowhile(id, expr, expr_id, block) ::= <<
br label %<vloop_entry(id)>

<vloop_entry(id)>:
  <block>
  
  <expr>
  br i1 <vlocal_result(expr_id)>, label %<vloop_entry(id)>, label %<vloop_done(id)>
  
<vloop_done(id)>:

>>

loop(id, block) ::= <<
br label %<vloop_entry(id)>

<vloop_entry(id)>:
  <block>
  
  br label %<vloop_entry(id)>
  
<vloop_done(id)>:

>>

break(id, loop_id) ::= <<
  br label %<vloop_done(loop_id)>
>>

continue(id, loop_id) ::= <<
  br label %<vloop_entry(loop_id)>
>>

